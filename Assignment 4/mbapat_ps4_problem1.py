# -*- coding: utf-8 -*-
"""mbapat_PS4_Problem1

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Q_TNLpDj9bklWQeVET_cygaYlUD2_OZU

# **Problem 1 - Build MD Code for NVT and NVE**
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
# %matplotlib inline
import matplotlib.pyplot as plt
import numba
from numba import vectorize, njit, jit, prange
import scipy as sp
import time

"""## **Define initial values of positions and velocities, initialize arrays & define time array:**"""

atoms_x0 = np.loadtxt('https://raw.githubusercontent.com/mhlbapat/f20-24623/master/Assignment%203/liquid256.txt')
time_step = 0.002
total_time = 200
mass = 1 #Mass of each atom assumed to be unity
rc = 2.5 #cutoff radius
dudrc = 4*((-12/rc**13) + (6/rc**7))
L_box = 6.8 #Dimensionless length of our simulation box

"""## **Some functions to make life easy**"""

# Initialize velocity randomly
def random_v0(pos_x0, T):
  """
  Input: The initial position matrix 
  Output: randomy initializes the velocity of the particles such that
  the initial momentum of the system is zero. We can set the seed for this
  to check the consistency in results obtained.
  """
  np.random.seed(10)
  kb = 1.381e-23 #J/K
  epAr = 1.65e-21 #J
  # T = 130 # K
  T_start = kb*T/epAr
  N_atoms = np.int(np.shape(pos_x0)[0])
  avgs_xyz = np.sqrt(T_start*(N_atoms-1)/N_atoms)
  atoms_list = np.arange(N_atoms)
  vel_v0 = np.zeros(np.shape(pos_x0))

  for i in range(np.shape(pos_x0)[1]):
    positive = np.random.choice(N_atoms, np.int(N_atoms/2), replace=False)
    negative  = np.setdiff1d(atoms_list,positive)
    for loop in positive:
      vel_v0[loop,i] = avgs_xyz
    for loop in negative:
      vel_v0[loop,i] = -avgs_xyz

  return vel_v0

# Total Time Function
@njit
def time_func(step_size,tot_time):
  N_steps = np.int((tot_time/step_size)+1)
  t_vals = np.zeros(N_steps)
  for i in range(N_steps-1):
    t_vals[i+1] = t_vals[i] + step_size
  return t_vals


# Positions and Velocities of Center of Mass
@jit
def centre_of_mass(position_atoms, velocity_atoms):
  """
  Input: Positions and velocities at different time-steps in two 3D arrays
  Output: XYZ Positions and XYZ Velocities of COM at different time-steps in two 2D arrays.
  """
  com_pos = np.zeros((np.shape(position_atoms)[2],np.shape(position_atoms)[1]))
  com_vel = np.zeros((np.shape(position_atoms)[2],np.shape(position_atoms)[1]))
  for i in prange(np.shape(position_atoms)[2]):
    com_pos[i] = np.sum(position_atoms[:,:,i],axis=0)/np.shape(position_atoms[:,:,i])[0]
    com_vel[i] = np.sum(velocity_atoms[:,:,i],axis=0)/np.shape(velocity_atoms[:,:,i])[0]
  
  return com_pos, com_vel

# Periodic Boundary Condition
@njit
def periodic_bc(pos_all, L_simbox = L_box):
  """
  Input: Position of all atoms at the given time-step & Simulation Box Side Length
  Output: Updated Positions of all atoms at the given time-step
  after applying the Periodic Boundary Conditions
  """
  counter_array = np.zeros(np.shape(pos_all))

  for i in prange(np.shape(pos_all)[0]):
    for k in range(np.shape(pos_all)[1]):
      if pos_all[i,k] < 0:
        pos_all[i,k] = pos_all[i,k] + L_simbox
        counter_array[i,k] = -1

      if pos_all[i,k] > L_simbox:
        pos_all[i,k] = pos_all[i,k] - L_simbox
        counter_array[i,k] = 1


  return pos_all, counter_array

# Minimum Image Convention
@njit(parallel=True)
def near_imgcon(pos_atom, pos_all, L_simbox=L_box):
  """
  Input: Position of considered atom and the positions of all atoms at a given time-step & 
  Simulation Box Side Length
  Output: Updated distance of the considered atom at the given time-step in the three directions
  """

  relative_pos = pos_all - pos_atom

  for i in prange(np.shape(relative_pos)[0]):
    for k in range(np.shape(relative_pos)[1]):
      if relative_pos[i,k] < -L_simbox/2:
        relative_pos[i,k] = (relative_pos[i,k] + L_simbox)
      if relative_pos[i,k] > L_simbox/2:
        relative_pos[i,k] = (relative_pos[i,k] - L_simbox)
  return relative_pos




# Force at a time step
@njit
def force_all(pos_all):
  """
  Input: Position of all atoms at a given time-step after applying change in position
  due to the periodic boundary condition.
  Output: Force vector in 3D for all atoms using
  Analytical Gradient of Lennard Jones Potential (dimensionless)
  and the Virial Pressure term without the volume factor
  """
  force_vec = np.zeros(np.shape(pos_all))
  # natoms_vec = np.zeros(np.shape(pos_all)[0])
  press_term = 0

  for i in prange(np.shape(pos_all)[0]):

    updated_dist = near_imgcon(pos_all[i],pos_all)
    r = np.sqrt(np.sum((updated_dist)**2, axis=1))
    req_index = np.where((r>0) & (r<=rc))
    # natoms_vec[i] = len(req_index[0])
    force_ij = np.zeros(np.shape(pos_all))
    for j in req_index[0]:
      r_dash = r[j]
      temp_var = 4*((-12/(r_dash**13))  - (-6/r_dash**7)) - dudrc
      press_term = press_term + (temp_var*r_dash)
      force_ij[j] = np.multiply(temp_var , ((updated_dist[j])/r_dash))

    force_vec[i] = np.sum(force_ij,axis=0)

  return force_vec, press_term


#Instantaneous Pressure for all time-steps
@njit
def instant_press(pos_atoms ,press_term, T_inst):
  """
  Input: Pressure Term from force function and the Instantaneous Temperature at all time-steps.
  Output: Pressure of the system at each time-step.
  """
  N_atoms = np.shape(pos_atoms)[0]
  P_total = np.zeros(np.shape(pos_atoms)[2])
  V = L_box**3

  P_total =  -(press_term/(3*V)) + (N_atoms*T_inst/V)
  return P_total




# Lennard Jones Potential
@njit
def ljfunc(r):
  """
  Input: The distance r
  Output: The Lennard Jones Potential Energy, scalar.
  """
  lje = 4*((1/(r**12)) - (1/(r**6)))
  return lje

# Potential Energy at all time-steps
@njit
def potential_energy(position_atoms):
  """
  Input: Position of atoms at different time-steps.
  Output: Total Potential Energy of the system at each time-step.
  """

  delUdrc = 4*((-12/rc**13) - (-6/rc**7))
  pe_all = np.zeros(np.shape(position_atoms)[2])
  energy_temp = np.zeros(np.shape(position_atoms)[0])

  for i in range(np.shape(position_atoms)[2]):
    for j in range(np.shape(position_atoms)[0]):
      atomj = position_atoms[j,:,i]
      atomi_all = position_atoms[:,:,i]
      updated_dist = near_imgcon(atomj,atomi_all)
      r = np.sqrt(np.sum((updated_dist)**2, axis=1))
      req_index = np.where((r>0) & (r<=rc))
      sum_en = 0
      for k in req_index[0]:
        sum_en = sum_en + ljfunc(r[k]) - ljfunc(rc) - ((r[k]-rc)*delUdrc)
      energy_temp[j] = sum_en
    pe_all[i] = np.sum(energy_temp)/2 #To account for double counting

  return pe_all


# Kinetic Energy at all time-steps
@jit
def kinetic_energy(velocity_atoms):
  """
  Input: Velocity of all atoms at all time-steps
  Output: Kinetic Energy at each time-step.
  """
  ke_all = np.zeros(np.shape(velocity_atoms)[2])
  for i in prange(len(ke_all)):
    ke_all[i] = 0.5*np.sum(velocity_atoms[:,:,i]**2)  
  return ke_all

# Temperature at a given time-step
@njit
def instant_temp(vel_atoms):
  """
  Input: Velocity of all the atoms at each time step of velocity verlet.
  Output: Temperature of the system at the given time-step.
  """
  N_atoms = np.shape(vel_atoms)[0] #number of atoms in the system
  ke_tot = 0.5*np.sum(vel_atoms**2)
  T_inst = 2*ke_tot/(3*(N_atoms-1)) #Dimensionless Instantaneous temperature

  return T_inst


# Zeta Dot Function
@njit
def zeta_dot(vel_atoms , T_des, tau_damp):
  T_inst = instant_temp(vel_atoms)
  # print(T_inst)
  zdot = (1/(tau_damp**2))*( (T_inst/T_des) -1 )
  return zdot


@njit
def instant_temp_all(vel_atoms):
  """
  Input: Velocity of all the atoms at all time steps after velocity verlet.
  Output: Temperature of the system at each time-step.
  """
  # ke_system =  #Total Kinetic Energy of system with time
  N_atoms = np.shape(vel_atoms)[0] #number of atoms in the system
  T_inst = 2*kinetic_energy(vel_atoms)/(3*(N_atoms-1)) #Dimensionless Instantaneous temperature

  return T_inst

@njit
def MSD_func(pos_all, init_pos):
  disp = pos_all - init_pos
  msd_val = np.sum(disp**2)/np.shape(pos_all)[0]
  return msd_val

"""## **Velocity Verlet Function:**"""

@njit
def velocity_verlet(pos_atoms0 , vel_atoms0 , t_step_size, tot_time, t_nvt, T_des, tau_damp=0.05):

  """
  Input: Initial Positions, Initial Velocities, time-step, total time & 
  time upto which NVT ensemble has to be run. After that NVE ensemble will continue
  tau_damp = damping coefficient for Temperature control
  Output: Position and Velocity arrays with each time-step using
  velocity verlet algorithm along with periodic boundary conditions and
  minimum image convention.
  """
  print(T_des)
  time_vals = time_func(t_step_size, tot_time)
  time_nvt = time_vals[time_vals<=t_nvt]
  N_tvals = len(time_vals)
  msd_values = np.zeros(len(time_vals))

  # Define Position, Velocity, Force and vtby2 arrays
  pos_atoms_all = np.zeros((np.shape(pos_atoms0)[0],np.shape(pos_atoms0)[1],len(time_vals)))
  counter_vals = np.zeros(np.shape(pos_atoms_all))
  pos_atoms_all[:,:,0] = pos_atoms0

  vel_atoms_all = np.zeros(np.shape(pos_atoms_all))
  vel_atoms_all[:,:,0] = vel_atoms0

  vhalf_all = np.zeros(np.shape(vel_atoms_all))     #Velocity vector at t+del_t/2
  fj_ti_all = np.zeros(np.shape(pos_atoms_all))     #Force on particle j at time step i

  # Define zeta function : Temperature error value
  zeta_vals = np.zeros(np.shape(time_nvt))


  # avg_force_calc = np.zeros(N_tvals)
  pressure_array = np.zeros(np.shape(time_vals))
  fj_ti_all[:,:,0], pressure_array[0] = force_all(pos_atoms_all[:,:, 0]) #Force on atom j at timestep i
  zeta_vals[0] = zeta_dot(vel_atoms_all[:,:,0], T_des, tau_damp)
  counter_vals[:,:, 0]  = 0


  print('Performing calculations using NVT Ensemble.....')
  for i in range(len(time_nvt)-1):
    # print(i)
    vhalf_all[:,:,i] = vel_atoms_all[:,:,i] + (  ( (fj_ti_all[:,:,i]/mass) -  (zeta_vals[i]*vel_atoms_all[:,:,i])) * (time_step/2))
    pos_atoms_all[:,:, i+1] = pos_atoms_all[:,:,i] + (vhalf_all[:,:,i]*time_step)


    zeta_vals[i+1] = zeta_vals[i] + (zeta_dot(vel_atoms_all[:,:,i], T_des, tau_damp)*time_step)
    # print(zeta_vals[i])

    pos_atoms_all[:,:,i+1], counter_vals[:,:,i+1] = periodic_bc(pos_atoms_all[:,:,i+1])
    fj_ti_all[:,:,i+1], pressure_array[i+1] = force_all(pos_atoms_all[:,:, i+1]) #Force on atom j at timestep i+1

    vel_atoms_all[:,:,i+1] = (vhalf_all[:,:,i] + ((fj_ti_all[:,:,i+1]/mass)*(time_step/2)))/(1+ (zeta_vals[i+1]*time_step/2))

    if ((i)*100/(N_tvals-1))%10 == 0:
      print('Completed ' , np.floor((i)*100/(N_tvals-1)), ' %')

    if np.abs((instant_temp(vel_atoms_all[:,:,i+1])/T_des)-1)<1e-2 and time_nvt[i]>0.9*t_nvt:
      N_break = i
      break

  
  print('Performing calculations using NVE Ensemble......')
  for i in range(N_break,len(time_vals)-1):
    # print(i)

    vhalf_all[:,:,i] = vel_atoms_all[:,:,i] + ((fj_ti_all[:,:,i]/mass)*(time_step/2))
    pos_atoms_all[:,:, i+1] = pos_atoms_all[:,:,i] + (vhalf_all[:,:,i]*time_step)

    pos_atoms_all[:,:,i+1], counter_vals[:,:,i+1] = periodic_bc(pos_atoms_all[:,:,i+1])
    fj_ti_all[:,:,i+1], pressure_array[i+1] = force_all(pos_atoms_all[:,:, i+1]) #Force on atom j at timestep i+1

    vel_atoms_all[:,:,i+1] = vhalf_all[:,:,i] + ((fj_ti_all[:,:,i+1]/mass)*(time_step/2))
    

    if ((i)*100/(N_tvals-1))%10 == 0:
      print('Completed ' , np.floor((i)*100/(N_tvals-1)), ' %')


  return pos_atoms_all, vel_atoms_all, pressure_array, time_nvt[N_break], counter_vals

"""## **Run the Simulation**"""

st = time.time()
atoms_x0 = np.loadtxt('https://raw.githubusercontent.com/mhlbapat/f20-24623/master/Assignment%203/liquid256.txt')
Tinitial = np.linspace(100,140,11)
diff_all  = np.zeros(np.shape(Tinitial))
diffT_array = np.zeros((np.shape(Tinitial)[0],2))
# diffT_array[:,0] = Tinitial
time_step = 0.002
total_time = 80
mass_Ar_dim = 6.6335209e-26 #kg, mass of Argon in dimensional units
sigma_Ar = 3.4e-10 #meters
kb = 1.381e-23 #J/K
ep_Ar = 1.66e-21 #Joules, epsilon value of Argon

for loop in range(len(Tinitial)):
  print('Calculations for T = ', Tinitial[loop])
  T_desired = Tinitial[loop]*kb/ep_Ar
  atoms_v0 = random_v0(atoms_x0, Tinitial[loop])


  nvt_time = 50
  atoms_x_all, atoms_v_all, pressure_array, nvt_time, counters = velocity_verlet(atoms_x0, atoms_v0, time_step, total_time, nvt_time , T_desired)
  print('Time Taken: ', time.time()-st)
  cm_position, cm_velocity = centre_of_mass(atoms_x_all,atoms_v_all)
  pe_all_atoms = potential_energy(atoms_x_all)
  ke_all_atoms = kinetic_energy(atoms_v_all)
  te_all_atoms = pe_all_atoms + ke_all_atoms
  print('Doing pressure & temperature calculations.....')
  st = time.time()
  Temp_all = instant_temp_all(atoms_v_all)
  # Pressure_all = instant_press(atoms_x_all,pressure_array, Temp_all)
  print('Time Taken', time.time()-st)

  print('\nSaving Results.....')
  folp = '/content/drive/My Drive/Courses/Fall 2020/24623 - Molecular Simulations of Materials/Assignments/PS4/self-diffusion/'
  data_array1 = np.array([total_time, time_step, nvt_time, T_desired*ep_Ar/kb])
  np.savetxt(folp+'op_con_' + str(Tinitial[loop])+ '.txt', data_array1 , header='total_time, time_step, nvt_time, T_desired(K)')
  np.savetxt(folp+'com-velocity_' + str(Tinitial[loop])+ '.txt', cm_velocity)
  np.savetxt(folp+'com-position_' + str(Tinitial[loop])+ '.txt', cm_position)
  np.savetxt(folp+'temperature_' + str(Tinitial[loop])+ '.txt', Temp_all)
  np.savetxt(folp+'pressure_' + str(Tinitial[loop])+ '.txt', Pressure_all)
  np.savetxt(folp+'potential_energy_' + str(Tinitial[loop])+ '.txt', pe_all_atoms)
  np.savetxt(folp+'kinetic_energy_' + str(Tinitial[loop])+ '.txt', ke_all_atoms)
  np.savetxt(folp+'total_energy_' + str(Tinitial[loop])+ '.txt', te_all_atoms)

  org_pos = np.zeros(np.shape(atoms_x_all))
  counters_cum = np.cumsum(counters,axis=2)
  org_pos = atoms_x_all + counters_cum*L_box
  MSD_vals = np.sum((org_pos - np.reshape(atoms_x_all[:,:,0], (np.shape(atoms_x_all)[0], np.shape(atoms_x_all)[1],1)))**2, axis=(0,1))/np.shape(atoms_x_all)[0]

  np.savetxt(folp+'MSD_' + str(Tinitial[loop])+ '.txt', MSD_vals)

  time_values = time_func(time_step, total_time)
  nvt = np.where(time_values<=nvt_time)
  nve = np.where(time_values>nvt_time)
  coeff_msd = np.polyfit(time_values[nve],MSD_vals[nve],1)
  diffT_array[loop, 0] = np.mean(Temp_all)
  diffT_array[loop, 1] = coeff_msd[0]/6

np.savetxt(folp+'selfD.txt', diffT_array, header='T_des(K), Diffusion-Coeff')

  # print('Saving final positions.......')
  # data_final = atoms_x_all[:,:,-1]
  # final = open(folp+'positions_'+str(Tinitial[loop])+'.xyz','w')
  # final.write(str(np.shape(data_final)[0]))
  # final.write('\n# Final Positions for a temperature = '+ str(Tinitial[loop])+' K \n')
  # for i in range(np.shape(data_final)[0]):
  #   final.write('a')
  #   for j in range(np.shape(data_final)[1]):
  #     ss = ' ' + str(data_final[i][j])
  #     final.write(ss)
  #   final.write('\n')
  # final.close()

"""## **a) PE, KE, Temperature, Pressure at 100K**"""

DH = ['op_con_','com-velocity_', 'com-position_','temperature_' ,'pressure_' , 'potential_energy_', 'kinetic_energy_', 'total_energy_', 'MSD_']
for i in range(len(DH)):
  print('Value:  ', i, DH[i])
# Total Time Function
@njit
def time_func(step_size,tot_time):
  N_steps = np.int((tot_time/step_size)+1)
  t_vals = np.zeros(N_steps)
  for i in range(N_steps-1):
    t_vals[i+1] = t_vals[i] + step_size
  return t_vals

mass_Ar_dim = 6.6335209e-26 #kg, mass of Argon in dimensional units
sigma_Ar = 3.4e-10 #meters
kb = 1.381e-23 #J/K
ep_Ar = 1.66e-21 #Joules, epsilon value of Argon

folp = '/content/drive/My Drive/Courses/Fall 2020/24623 - Molecular Simulations of Materials/Assignments/PS4/data/'
savep = '/content/drive/My Drive/Courses/Fall 2020/24623 - Molecular Simulations of Materials/Assignments/PS4/'

T_des = 100

total_time, time_step, nvt_time, _ = np.loadtxt(folp+ DH[0] +str(T_des)+'.txt')

time_vals = time_func(time_step, total_time)
TE = np.loadtxt(folp+DH[7]+str(T_des)+'.txt')
KE = np.loadtxt(folp+DH[6]+str(T_des)+'.txt')
PE = np.loadtxt(folp+DH[5]+str(T_des)+'.txt')
tempval = np.loadtxt(folp+DH[3]+str(T_des)+'.txt')*ep_Ar/kb
press = np.loadtxt(folp+DH[4]+str(T_des)+'.txt')


nvt = np.where(time_vals<=nvt_time)
nve = np.where(time_vals>nvt_time)

plt.plot(time_vals[nve], PE[nve] )
plt.plot(time_vals[nve], KE[nve] )
plt.plot(time_vals[nve] ,TE[nve])
plt.grid()
plt.xlabel('Time (Dimensionless)')
plt.ylabel('Energies (Dimensionless)')
plt.legend(['Potential Energy', 'Kinetic Energy', 'Total Energy'], bbox_to_anchor=(1,1))
plt.savefig(savep+'energies_'+str(T_des)+'.png', dpi=300, bbox_inches='tight'   )
plt.show()

plt.plot(time_vals[nvt] ,tempval[nvt])
plt.plot(time_vals[nve] ,tempval[nve])
plt.legend(['NVT', 'NVE'], bbox_to_anchor=(1,1))
plt.xlabel('Time (Dimensionless)')
plt.ylabel('Temperature (K)')
plt.grid()
plt.savefig(savep+'temperature_'+str(T_des)+'.png', dpi=300, bbox_inches='tight')

plt.show()

plt.plot(time_vals[nvt] ,press[nvt])
plt.plot(time_vals[nve] ,press[nve])
plt.legend(['NVT', 'NVE'], bbox_to_anchor=(1,1))
plt.xlabel('Time (Dimensionless)')
plt.ylabel('Pressure (Dimensionless)')
plt.grid()
plt.savefig(savep+'pressure_'+str(T_des)+'.png', dpi=300, bbox_inches='tight')

plt.show()


plt.plot(time_vals[nve] ,tempval[nve])
# plt.legend(['NVT', 'NVE'], bbox_to_anchor=(1,1))
plt.xlabel('Time (Dimensionless)')
plt.ylabel('Temperature (K)')
plt.grid()
plt.savefig(savep+'temp_nve_'+str(T_des)+'.png', dpi=300, bbox_inches='tight')

plt.show()

np.mean(tempval[nve]), nvt_time, np.mean(PE[nve]), np.mean(KE[nve]), np.mean(press[nve])

"""## **(b) Equilibrium Reached?**"""

mean_nve = np.mean(tempval[nve])*np.ones(np.shape(tempval[nve]))
cum_mean_nve  = np.cumsum(tempval[nve])/np.arange(1,np.shape(time_vals[nve])[0]+1)


plt.figure(figsize=(10,3))
plt.plot(time_vals[nve] ,tempval[nve], 'y')
plt.plot(time_vals[nve] ,mean_nve, 'r.--')
plt.plot(time_vals[nve] ,cum_mean_nve, '.--')
plt.legend(['Temperature', 'Mean Temperature', 'Cumulative Mean'], bbox_to_anchor=(1,1))
plt.xlabel('Time (Dimensionless)')
plt.ylabel('Temperature (K)')
plt.grid()
plt.savefig(savep+'cumtemp_nve_'+str(T_des)+'.png', dpi=300, bbox_inches='tight')
plt.show()

temp_equi = 0
for i in range(len(time_vals[nve])):
  condition1 = np.abs(cum_mean_nve[i]-np.mean(tempval[nve]))/np.mean(tempval[nve]) < 0.005
  condition2 = np.all(np.abs(cum_mean_nve[i:]-np.mean(tempval[nve]))/np.mean(tempval[nve]) < 0.005)
  if condition1 and condition2:
    temp_equi = (time_vals[nve])[i]
    break
print(temp_equi)

"""## **(c) MSD vs. Time**"""

folp = '/content/drive/My Drive/Courses/Fall 2020/24623 - Molecular Simulations of Materials/Assignments/PS4/self-diffusion/'
savep = '/content/drive/My Drive/Courses/Fall 2020/24623 - Molecular Simulations of Materials/Assignments/PS4/'

T_desired = [100] #np.linspace(100,140,11)
sd_vals = np.zeros(np.shape(T_desired))

for i in range(len(T_desired)):
  T_des = T_desired[i]
  total_time, time_step, nvt_time, _ = np.loadtxt(folp+ DH[0] +str(T_des)+'.txt')
  time_vals = time_func(time_step, total_time)
  msd_vals = np.loadtxt(folp+DH[8]+str(T_des)+'.txt')
  nvt = np.where(time_vals<=nvt_time)
  nve = np.where(time_vals>nvt_time)
  coeff_msd = np.polyfit(time_vals[nve], msd_vals[nve],1)
  sd_vals[i] = coeff_msd[0]/6

  plt.figure()
  plt.tight_layout()
  plt.plot(time_vals[nve] ,msd_vals[nve], 'r.-')
  plt.title(f'Temperature = {T_des:1.3f}')
  plt.xlabel('Time (Dimensionless)')
  plt.ylabel('Mean Squared Displacement')
  plt.grid()
  plt.savefig(savep+'msd_nve_'+str(T_des)+'.png', dpi=300)
  plt.show()

print(sd_vals)

coeff_msd = np.polyfit(time_vals[nve],msd_vals[nve],1)
print(coeff_msd[0]/6)
plt.tight_layout()
plt.plot(time_vals[nve] ,msd_vals[nve], 'r')
plt.plot(time_vals[nve], np.polyval(coeff_msd,time_vals[nve]), '--')
plt.legend(['MSD Data', 'Fitted Line'], bbox_to_anchor=(1,1))
plt.xlabel('Time (Dimensionless)')
plt.ylabel('Mean Squared Displacement')
plt.grid()
plt.savefig(savep+'msdfit_nve_'+str(T_des)+'.png', dpi=300, bbox_inches='tight')
plt.show()
print(np.poly1d(coeff_msd)[1]/6)

"""## **(e) Self-Diffusion Coeffcient vs. Temperature**"""

sd_data = np.loadtxt('/content/drive/My Drive/Courses/Fall 2020/24623 - Molecular Simulations of Materials/Assignments/PS4/self-diffusion/selfD.txt')
temp_data = sd_data[:,0]*ep_Ar/kb
sd = sd_data[:,1]
plt.plot(temp_data, sd, 'o--')
plt.xlabel('Temperature (K)')
plt.ylabel('Self-Diffusion Coefficient (Dimensionless)')
plt.grid()
# plt.savefig(savep+'sd_all.png', dpi=300)
plt.show()