# -*- coding: utf-8 -*-
"""mbapat_PS3_Problem3

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LibdpNR8ReZJivcNiC5BMs23o4n69lgD

# **Problem 3 - Build MD Code**

## **Let us start by defining a function to randomly initialize the velocities of all the particles such that initial momentum is zero:**
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
# %matplotlib inline
import matplotlib.pyplot as plt
import numba
from numba import vectorize, njit, jit, prange
import scipy as sp
import time

def random_v0(pos_x0):
  """
  Input: The initial position matrix 
  Output: randomy initializes the velocity of the particles such that
  the initial momentum of the system is zero. We can set the seed for this
  to check the consistency in results obtained.
  """
  np.random.seed(10)
  kb = 1.381e-23 #J/K
  epAr = 1.65e-21 #J
  T = 130 # K
  T_start = kb*T/epAr
  N_atoms = np.int(np.shape(pos_x0)[0])
  avgs_xyz = np.sqrt(T_start*(N_atoms-1)/N_atoms)
  atoms_list = np.arange(N_atoms)
  vel_v0 = np.zeros(np.shape(pos_x0))

  for i in range(np.shape(pos_x0)[1]):
    positive = np.random.choice(N_atoms, np.int(N_atoms/2), replace=False)
    negative  = np.setdiff1d(atoms_list,positive)
    for loop in positive:
      vel_v0[loop,i] = avgs_xyz
    for loop in negative:
      vel_v0[loop,i] = -avgs_xyz

  return vel_v0

# np.mean((random_v0(atoms_x0)))

"""## **Define initial values of positions and velocities, initialize arrays & define time array:**"""

atoms_x0 = np.loadtxt('https://raw.githubusercontent.com/mhlbapat/f20-24623/master/Assignment%203/liquid256.txt')
atoms_v0 = random_v0(atoms_x0)

time_step = 0.002
total_time = 200

@njit
def time_func(step_size,tot_time):
  N_steps = np.int((tot_time/step_size)+1)
  t_vals = np.zeros(N_steps)
  for i in range(N_steps-1):
    t_vals[i+1] = t_vals[i] + step_size
  return t_vals

time_vals = time_func(time_step,total_time)


mass = 1 #Mass of each atom assumed to be unity

print(np.max(np.abs(random_v0(atoms_x0)), axis=0), np.shape(time_vals))

#Initializing Variables
atoms_x_all = np.zeros((np.shape(atoms_x0)[0],np.shape(atoms_x0)[1],len(time_vals)))
atoms_x_all[:,:,0] = atoms_x0
atoms_v_all = np.zeros(np.shape(atoms_x_all))
atoms_v_all[:,:,0] = atoms_v0
v_tby2 = np.zeros(np.shape(atoms_v_all)) #Velocity vector at t+del_t/2
fj_ti = np.zeros(np.shape(atoms_x_all)) #Force on particle j at time step i
rc = 3.1 #cutoff radius
dudrc = 4*((-12/rc**13) + (6/rc**7))
L_box = 6.8 #Dimensionless length of our simulation box

"""## **Plot the initial positions of particles to visualize the initial positions of atoms:**"""

#Plottin in 3D to check if data file was read
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
ax.scatter(atoms_x_all[:,0,0], atoms_x_all[:,1,0], atoms_x_all[:,2,0], c='r', marker='o')
ax.set_xlabel('X Label')
ax.set_ylabel('Y Label')
ax.set_zlabel('Z Label')
plt.savefig('/content/drive/My Drive/Courses/Fall 2020/24623 - Molecular Simulations of Materials/Assignments/PS3/initial_positions.png', dpi=300, bbox_inches='tight')

"""## **Function for calculating the positions and velocities of centre of Mass:**"""

@jit
def centre_of_mass(position_atoms, velocity_atoms):
  """
  Input: Positions and velocities at different time-steps in two 3D arrays
  Output: XYZ Positions and XYZ Velocities of COM at different time-steps in two 2D arrays.
  """
  com_pos = np.zeros((np.shape(position_atoms)[2],np.shape(position_atoms)[1]))
  com_vel = np.zeros((np.shape(position_atoms)[2],np.shape(position_atoms)[1]))
  for i in prange(np.shape(position_atoms)[2]):
    com_pos[i] = np.sum(position_atoms[:,:,i],axis=0)/np.shape(position_atoms[:,:,i])[0]
    com_vel[i] = np.sum(velocity_atoms[:,:,i],axis=0)/np.shape(velocity_atoms[:,:,i])[0]
  
  return com_pos, com_vel

"""## **Periodic Boundary Conditions:**"""

@njit(parallel=True)
def periodic_bc(pos_all, L_simbox = L_box):
  """
  Input: Position of all atoms at the given time-step & Simulation Box Side Length
  Output: Updated Positions of all atoms at the given time-step
  after applying the Periodic Boundary Conditions
  """
  
  for i in prange(np.shape(pos_all)[0]):
    for k in range(np.shape(pos_all)[1]):
      if pos_all[i,k] < 0:
        pos_all[i,k] = pos_all[i,k] + L_simbox

      if pos_all[i,k] > L_simbox:
        pos_all[i,k] = pos_all[i,k] - L_simbox


  return pos_all

np.max(atoms_x0),np.max(periodic_bc(atoms_x0))

"""## **Minimum Image Convention:**"""

@njit(parallel=True)
def near_imgcon(pos_atom, pos_all, L_simbox=L_box):
  """
  Input: Position of considered atom and the positions of all atoms at a given time-step & 
  Simulation Box Side Length
  Output: Updated distance of the considered atom at the given time-step in the three directions
  """

  relative_pos = pos_all - pos_atom

  for i in prange(np.shape(relative_pos)[0]):
    for k in range(np.shape(relative_pos)[1]):
      if relative_pos[i,k] < -L_simbox/2:
        relative_pos[i,k] = (relative_pos[i,k] + L_simbox)
      if relative_pos[i,k] > L_simbox/2:
        relative_pos[i,k] = (relative_pos[i,k] - L_simbox)
  return relative_pos

(atoms_x0- atoms_x0[0,:])[5], near_imgcon(atoms_x0[0,:], atoms_x0)[5]

"""## **Define the force for our simulation using the Continous Energy/Continous Force Cutoff Scheme**"""

@njit
def force_all(pos_all):
  """
  Input: Position of all atoms at a given time-step after applying change in position
  due to the periodic boundary condition.
  Output: Force vector in 3D for all atoms using
  Analytical Gradient of Lennard Jones Potential (dimensionless)
  """
  force_vec = np.zeros(np.shape(pos_all))
  natoms_vec = np.zeros(np.shape(pos_all)[0])

  for i in prange(np.shape(pos_all)[0]):

    updated_dist = near_imgcon(pos_all[i],pos_all)
    r = np.sqrt(np.sum((updated_dist)**2, axis=1))
    req_index = np.where((r>0) & (r<=rc))
    natoms_vec[i] = len(req_index[0])
    force_ij = np.zeros(np.shape(pos_all))
    for j in req_index[0]:
      r_dash = r[j]
      force_ij[j] = np.multiply(4*((-12/(r_dash**13))  - (-6/r_dash**7)) - dudrc , ((updated_dist[j])/r_dash))

    force_vec[i] = np.sum(force_ij,axis=0)

  return force_vec, np.mean(natoms_vec)

# force_all(atoms_x0)[1]

"""## **Velocity Verlet Function:**"""

@njit
def velocity_verlet(pos_atoms_all,vel_atoms_all, fj_ti_all, vhalf_all,t_step_size,tot_time):

  """
  Input: Position, Velocity, Force, V @ del_t by 2 arrays, time-step & total time
  Output: Position and Velocity arrays with each time-step using
  velocity verlet algorithm along with periodic boundary conditions and
  minimum image convention.
  """
  time_vals = time_func(t_step_size, tot_time)
  N_tvals = len(time_vals)
  avg_force_calc = np.zeros(N_tvals)

  for i in range(len(time_vals)-1):

    # pos_atoms_all[:,:,i] = periodic_bc(pos_atoms_all[:,:,i])
    fj_ti_all[:,:,i], avg_force_calc[i] = force_all(pos_atoms_all[:,:, i]) #Force on atom j at timestep i

    vhalf_all[:,:,i] = vel_atoms_all[:,:,i] + ((fj_ti_all[:,:,i]/mass)*(time_step/2))
    pos_atoms_all[:,:, i+1] = pos_atoms_all[:,:,i] + (vhalf_all[:,:,i]*time_step)

    pos_atoms_all[:,:,i+1] = periodic_bc(pos_atoms_all[:,:,i+1])
    fj_ti_all[:,:,i+1], avg_force_calc[i+1] = force_all(pos_atoms_all[:,:, i+1]) #Force on atom j at timestep i+1

    vel_atoms_all[:,:,i+1] = vhalf_all[:,:,i] + ((fj_ti_all[:,:,i+1]/mass)*(time_step/2))
    

    if ((i)*100/(N_tvals-1))%10 == 0:
      print('Completed ' , np.floor((i)*100/(N_tvals-1)), ' %')


  return pos_atoms_all,vel_atoms_all, avg_force_calc

"""## **Calculate LJ Potential for a distance r:**"""

@njit
def ljfunc(r):
  """
  Input: The distance r
  Output: The Lennard Jones Potential Energy, scalar.
  """
  lje = 4*((1/(r**12)) - (1/(r**6)))
  return lje

"""## **Potential Energy for each time-step:**"""

@njit
def potential_energy(position_atoms):
  """
  Input: Position of atoms at different time-steps.
  Output: Total Potential Energy of the system at each time-step.
  """

  delUdrc = 4*((-12/rc**13) - (-6/rc**7))
  pe_all = np.zeros(np.shape(position_atoms)[2])
  energy_temp = np.zeros(np.shape(position_atoms)[0])

  for i in range(np.shape(position_atoms)[2]):
    for j in range(np.shape(position_atoms)[0]):
      atomj = position_atoms[j,:,i]
      atomi_all = position_atoms[:,:,i]
      updated_dist = near_imgcon(atomj,atomi_all)
      r = np.sqrt(np.sum((updated_dist)**2, axis=1))
      req_index = np.where((r>0) & (r<=rc))
      sum_en = 0
      for k in req_index[0]:
        sum_en = sum_en + ljfunc(r[k]) - ljfunc(rc) - ((r[k]-rc)*delUdrc)
      energy_temp[j] = sum_en
    pe_all[i] = np.sum(energy_temp)/2 #To account for double counting

  return pe_all

"""## **Kinetic Energy for each time-step:**"""

@jit
def kinetic_energy(velocity_atoms):
  """
  Input: Velocity of all atoms at all time-steps
  Output: Kinetic Energy at each time-step.
  """
  ke_all = np.zeros(np.shape(velocity_atoms)[2])
  for i in prange(len(ke_all)):
    ke_all[i] = 0.5*np.sum(velocity_atoms[:,:,i]**2)  
  return ke_all

"""## **Instantaneous Temperature:**"""

@njit
def instant_temp(vel_atoms):
  """
  Input: Velocity of all the atoms at all time steps after velocity verlet.
  Output: Temperature of the system at each time-step.
  """
  # ke_system =  #Total Kinetic Energy of system with time
  N_atoms = np.shape(vel_atoms)[0] #number of atoms in the system
  T_inst = 2*kinetic_energy(vel_atoms)/(3*(N_atoms-1)) #Dimensionless Instantaneous temperature

  return T_inst

"""## **Instantaneous Pressure:**"""

@njit
def instant_press(pos_atoms, vel_atoms, T_inst):
  """
  Input: Positions & Velocities of atoms at all time-steps.
  Output: Pressure of the system at each time-step.
  """
  N_atoms = np.shape(pos_atoms)[0]
  P_total = np.zeros(np.shape(pos_atoms)[2])
  V = L_box**3

  print(L_box)
  for i in range(np.shape(pos_atoms)[2]):
    if i%5000==0:
      print(i)
    
    press_term = 0
    for j in range(np.shape(pos_atoms)[0]):
      atomj = pos_atoms[j,:,i]
      atomk = pos_atoms[j+1:,:,i]
      updated_dist = near_imgcon(atomj,atomk, L_box)
      r = np.sqrt(np.sum((updated_dist)**2, axis=1))
      req_index = np.where((r> 0) & (r<=rc))
      for k in req_index[0]:
        r_dash = r[k]
        fjk = (4*((-12/(r_dash**13))  - (-6/r_dash**7)) - dudrc)*r_dash
        press_term = press_term + fjk
  
    P_total[i] =  -(press_term/(3*V)) + (N_atoms*T_inst[i]/V)
  return P_total

"""## **Finally!! Whew! Run the code.....**

This will take a while to run (~40 mins for time-step=0.002 and total time=200) \\
Here is a couple of youtube clips to kill time in a constructive manner..... \\
https://www.youtube.com/watch?v=twSvd5bQLDw \\
https://www.youtube.com/watch?v=-vZXgApsPCQ
"""

st = time.time()
atoms_x_all, atoms_v_all, average_fcal = velocity_verlet(atoms_x_all, atoms_v_all, fj_ti, v_tby2, time_step, total_time)
print('Time Taken: ', time.time()-st)
cm_position, cm_velocity = centre_of_mass(atoms_x_all,atoms_v_all)
pe_all_atoms = potential_energy(atoms_x_all)
ke_all_atoms = kinetic_energy(atoms_v_all)
te_all_atoms = pe_all_atoms + ke_all_atoms
print('Doing pressure & temperature calculations.....')
st = time.time()
Temp_all = instant_temp(atoms_v_all)
Pressure_all = instant_press(atoms_x_all,atoms_v_all, Temp_all)
print('Time Taken', time.time()-st)

"""## **Wait now....Its not over yet. Let's go over the results!**"""

folder_path = '/content/drive/My Drive/Courses/Fall 2020/24623 - Molecular Simulations of Materials/Assignments/PS3/rc_' + str(rc)

"""### **Positions and Velocities of COM**"""

file_path = folder_path + '/com_position_' + 'rc_' + str(rc) + '.png'
plt.plot(time_vals,cm_position[:,0])
plt.plot(time_vals,cm_position[:,1])
plt.plot(time_vals,cm_position[:,2])
plt.legend(['x','y','z'], bbox_to_anchor=(1.15,1))
plt.ylim([-1,5])
plt.ylabel('Position of Center of Mass');
plt.xlabel('Time')
plt.grid()
plt.savefig(file_path, dpi=300, bbox_inches='tight')
plt.show()


file_path = folder_path + '/com_velocity_' + 'rc_' + str(rc) + '.png'
plt.plot(time_vals,cm_velocity[:,0])
plt.plot(time_vals,cm_velocity[:,1])
plt.plot(time_vals,cm_velocity[:,2])
plt.legend(['x','y','z'], bbox_to_anchor=(1.15,1))
plt.ylim([-1e-12,1e-12])
plt.ylabel('Velocity of Center of Mass');
plt.xlabel('Time')
plt.grid()
plt.savefig(file_path, dpi=300, bbox_inches='tight')

"""### **Potential, Kinetic and Total Energy with time:**"""

file_path = folder_path + '/energies_' + 'rc_' + str(rc) + '.png'
plt.plot(time_vals,pe_all_atoms)
plt.plot(time_vals,ke_all_atoms)
plt.plot(time_vals,te_all_atoms)
plt.grid()
plt.ylabel('Energy (dimensionless)')
plt.xlabel('Time (dimensionless)')
plt.legend(['Potential Energy', 'Kinetic Energy', 'Total Energy'], bbox_to_anchor=(1.4,1))
plt.savefig(file_path, dpi=300, bbox_inches='tight')

"""### **Instantaneous Pressure and Temperature!**"""

file_path = folder_path + '/pressure_' + 'rc_' + str(rc) + '.png'
plt.plot(time_vals,Pressure_all)
plt.title('Pressure vs. Time')
plt.ylabel('Pressure (dimensionless)')
plt.xlabel('Time (dimensionless)')
plt.grid()
plt.savefig(file_path, dpi=300, bbox_inches='tight')
plt.show()

file_path = folder_path + '/temperature_' + 'rc_' + str(rc) + '.png'
plt.plot(time_vals,Temp_all)
plt.ylabel('Temperature (dimensionless)')
plt.title('Temperature vs. Time')
plt.xlabel('Time (dimensionless)')
plt.grid()
plt.savefig(file_path, dpi=300, bbox_inches='tight')

"""## **Don't Forget to save your results to a text file....**"""

file_path = folder_path + '/potential_' + 'rc_' + str(rc) + '.txt'
np.savetxt(file_path, pe_all_atoms)

file_path = folder_path + '/kinetic_' + 'rc_' + str(rc) + '.txt'
np.savetxt(file_path, ke_all_atoms)

file_path = folder_path + '/temp_data_' + 'rc_' + str(rc) + '.txt'
np.savetxt(file_path, Temp_all)

file_path = folder_path + '/press_data_' + 'rc_' + str(rc) + '.txt'
np.savetxt(file_path, Pressure_all)

file_path = folder_path + '/avg_fcal_' + 'rc_' + str(rc) + '.txt'
np.savetxt(file_path, average_fcal)

"""## **Writing the position array in a .xyz file for OVITO**"""

# if rc == 2.5:
#   file_path = folder_path + '/position_' + 'rc_' + str(rc) + '.xyz'
#   test1 = open(file_path,'w')
#   for i in range(np.shape(atoms_x_all)[2]):
#     test1.write(str(np.shape(atoms_x_all)[0]))
#     test1.write(f'\n# Time Step = {time_vals[i]}\n')
#     for j in range(np.shape(atoms_x_all)[0]):
#       test1.write('a')
#       for k in range(np.shape(atoms_x_all)[1]):
#         ss = ' ' + str(atoms_x_all[j][k][i])
#         test1.write(ss)
#       test1.write('\n')
#   test1.close()

"""## **Part (e) - Equillibrium**"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
# %matplotlib inline
import matplotlib.pyplot as plt

def time_func(step_size,tot_time):
  N_steps = np.int((tot_time/step_size)+1)
  t_vals = np.zeros(N_steps)
  for i in range(N_steps-1):
    t_vals[i+1] = t_vals[i] + step_size
  return t_vals

rc=2.5
folder_path = '/content/drive/My Drive/Courses/Fall 2020/24623 - Molecular Simulations of Materials/Assignments/PS3/rc_' + str(rc)

temp_data = np.loadtxt('https://raw.githubusercontent.com/mhlbapat/f20-24623/master/Assignment%203/rc_2.5/temp_data_rc_2.5.txt')
time_vals = time_func(2e-3,200)
cum_mean = np.cumsum(temp_data)/np.arange(1,np.shape(time_vals)[0]+1)
plt.plot(time_vals, temp_data)
plt.plot(time_vals, np.ones(np.shape(time_vals))*np.mean(temp_data), '.-')
plt.plot(time_vals, cum_mean, '-')
plt.legend(['Temperature', 'Mean Temperature', 'Cumulative Mean Temperature'], bbox_to_anchor=(1,1))
plt.ylabel('Temperature (dimensionless)')
plt.xlabel('Time (dimensionless)')
plt.savefig(folder_path + '/temp_avg_' + str(rc) +'.png', dpi=300, bbox_inches='tight')
plt.grid()
plt.show()

plt.plot(time_vals, np.ones(np.shape(time_vals))*np.mean(temp_data), '.-')
plt.plot(time_vals, cum_mean, '-')
plt.legend(['Mean Temperature', 'Cumulative Mean Temperature'], bbox_to_anchor=(1,1))
plt.ylabel('Temperature (dimensionless)')
plt.xlabel('Time (dimensionless)')
plt.grid()
plt.title('Zoomed In Graph')
print(np.mean(temp_data))
plt.ylim([0.835,0.842])
plt.savefig(folder_path + '/zoomedtemp_avg_' + str(rc) +'.png', dpi=300, bbox_inches='tight')

temp_equi = 0
for i in range(len(time_vals)):
  condition1 = np.abs(cum_mean[i]-np.mean(temp_data))/np.mean(temp_data) < 0.0005
  condition2 = np.all(np.abs(cum_mean[i:]-np.mean(temp_data))/np.mean(temp_data) < 0.0005)
  if condition1 and condition2:
    temp_equi = time_vals[i]
    break
print(temp_equi)

"""## **Part (f) - Time-averaged values**"""

git_folder = 'https://raw.githubusercontent.com/mhlbapat/f20-24623/master/Assignment%203/rc_2.5/'

pe = np.loadtxt(git_folder + 'potential_rc_' + str(rc) + '.txt')
ke = np.loadtxt(git_folder + 'kinetic_rc_' + str(rc) + '.txt')
pressure = np.loadtxt(git_folder + 'press_data_rc_' + str(rc) + '.txt')
temperature = np.loadtxt(git_folder + 'temp_data_rc_' + str(rc) + '.txt')

time100 = time_vals[time_vals>=100]
pe = pe[time_vals>=100]
ke = ke[time_vals>=100]
pressure = pressure[time_vals>=100]
temperature = temperature[time_vals>=100]

print(np.mean(pe), np.mean(ke), np.mean(pressure), np.mean(temperature))

mass_Ar_dim = 6.6335209e-26 #kg, mass of Argon in dimensional units
sigma_Ar = 3.4e-10 #meters
kb = 1.381e-23 #J/K
N_atoms = 256
ep_Ar = 1.66e-21 #Joules, epsilon value of Argon
0.8377942664165116*ep_Ar/kb, 1.6216936201295908*ep_Ar/((sigma_Ar**3)*1e6)

"""## **Part (g) - Different Cutoff Radii**

### **Cutoff Radius vs. Computation Time**
"""

import pandas as pd
dfrc = pd.read_csv('https://raw.githubusercontent.com/mhlbapat/f20-24623/master/Assignment%203/compute_time.csv')
r_cutoff = dfrc['rc']
compute_time = dfrc['compute time seconds']/60
plt.plot(r_cutoff, compute_time, 'o--')
plt.xlabel('Cutoff Radius (dimensionless)')
plt.ylabel('Computation Time (minutes)')
plt.grid()
# plt.savefig('/content/drive/My Drive/Courses/Fall 2020/24623 - Molecular Simulations of Materials/Assignments/PS3/compute_time_rc.png', dpi=300, bbox_inches='tight')

base_path = 'https://raw.githubusercontent.com/mhlbapat/f20-24623/master/Assignment%203/'

te_vals = np.zeros(np.shape(r_cutoff))
press_vals = np.zeros(np.shape(r_cutoff))
temp_vals = np.zeros(np.shape(r_cutoff))
pe_vals = np.zeros(np.shape(r_cutoff))
ke_vals = np.zeros(np.shape(r_cutoff))

rc_strs = ['rc_1.5', 'rc_1.9', 'rc_2.2', 'rc_2.5', 'rc_2.8', 'rc_3.1']
quan_path = ['/kinetic_','/potential_', '/press_data_', '/temp_data_']


for i in range(len(r_cutoff)):
  ke_vals[i] = np.mean(np.loadtxt(base_path + rc_strs[i] + quan_path[0] + rc_strs[i] + '.txt'))
  pe_vals[i] = np.mean(np.loadtxt(base_path + rc_strs[i] + quan_path[1] + rc_strs[i] + '.txt'))
  te_vals[i] = pe_vals[i] + ke_vals[i]
  press_vals[i] = np.mean(np.loadtxt(base_path + rc_strs[i] + quan_path[2] + rc_strs[i] + '.txt'))
  temp_vals[i] = np.mean(np.loadtxt(base_path + rc_strs[i] + quan_path[3] + rc_strs[i] + '.txt'))

plt.plot(r_cutoff,te_vals, 'ro--')
plt.xlabel('Cutoff Radius (dimensionless)')
plt.ylabel('Total Energy')
plt.grid()
plt.savefig('/content/drive/My Drive/Courses/Fall 2020/24623 - Molecular Simulations of Materials/Assignments/PS3/tot_energy_avg_rc.png', dpi=300, bbox_inches='tight')

plt.plot(r_cutoff,temp_vals, 'ro--')
plt.xlabel('Cutoff Radius (dimensionless)')
plt.ylabel('Time Averaged Temperature')
plt.grid()
plt.savefig('/content/drive/My Drive/Courses/Fall 2020/24623 - Molecular Simulations of Materials/Assignments/PS3/temp_avg_rc.png', dpi=300, bbox_inches='tight')

plt.plot(r_cutoff,press_vals, 'ro--')
plt.xlabel('Cutoff Radius (dimensionless)')
plt.ylabel('Time Averaged Pressure')
plt.grid()
plt.savefig('/content/drive/My Drive/Courses/Fall 2020/24623 - Molecular Simulations of Materials/Assignments/PS3/press_avg_rc.png', dpi=300, bbox_inches='tight')

base_path = 'https://raw.githubusercontent.com/mhlbapat/f20-24623/master/Assignment%203/'
avg_fcal = np.zeros(np.shape(r_cutoff)[0])
file_name = '/average_fcal.txt'
for i in range(len(r_cutoff)):
  avg_fcal[i] = np.mean(np.loadtxt(base_path+rc_strs[i]+file_name))

plt.plot(r_cutoff,avg_fcal,'ro--')
plt.xlabel('Cutoff Radius (dimensionless)')
plt.ylabel('Average Force Calculations')
plt.grid()
plt.savefig('/content/drive/My Drive/Courses/Fall 2020/24623 - Molecular Simulations of Materials/Assignments/PS3/avg_fcal.png', dpi=300, bbox_inches='tight')